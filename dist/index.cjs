"use strict";var ee=Object.create;var S=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var re=Object.getOwnPropertyNames;var se=Object.getPrototypeOf,oe=Object.prototype.hasOwnProperty;var ae=(s,e)=>{for(var t in e)S(s,t,{get:e[t],enumerable:!0})},C=(s,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of re(e))!oe.call(s,o)&&o!==t&&S(s,o,{get:()=>e[o],enumerable:!(r=te(e,o))||r.enumerable});return s};var l=(s,e,t)=>(t=s!=null?ee(se(s)):{},C(e||!s||!s.__esModule?S(t,"default",{value:s,enumerable:!0}):t,s)),ie=s=>C(S({},"__esModule",{value:!0}),s);var ue={};ae(ue,{default:()=>de});module.exports=ie(ue);var m=l(require("express"),1),A=l(require("cors"),1),b=l(require("path"),1),H=require("url"),J=l(require("dotenv"),1),Y=l(require("stripe"),1),Z=require("path");var G=require("child_process"),p=require("fs"),v=l(require("path"),1),j=class{pythonPath="python3";generatorScript="./music Gen extra/Main.py";outputDir="./storage/midi/generated";templatesDir="./storage/midi/templates";async generateMidi(e){try{await p.promises.mkdir(this.outputDir,{recursive:!0});let t=Date.now(),r=e.title.replace(/[^a-zA-Z0-9]/g,"_"),o=v.default.join(this.outputDir,`${r}_${t}.mid`),a=["./server/enhanced-midi-generator.py","--title",e.title,"--theme",e.theme,"--genre",e.genre,"--tempo",e.tempo.toString(),"--output",o];e.useAiLyrics&&a.push("--ai-lyrics"),e.duration&&a.push("--duration",e.duration.toString()),e.voiceId&&a.push("--voice-id",e.voiceId);let i=await this.executePythonScript(a);if(i.success){let d=await this.fileExists(o),n=o.replace(".mid","_metadata.json"),u=await this.fileExists(n);return{success:d,midiPath:d?o:void 0,metadataPath:u?n:void 0,error:d?void 0:"MIDI file was not generated"}}else return{success:!1,error:i.error}}catch(t){return{success:!1,error:`MIDI generation failed: ${t}`}}}async executePythonScript(e){return new Promise(t=>{let r=(0,G.spawn)(this.pythonPath,e),o="",a="";r.stdout.on("data",i=>{a+=i.toString()}),r.stderr.on("data",i=>{o+=i.toString()}),r.on("close",i=>{t(i===0?{success:!0}:{success:!1,error:`Process exited with code ${i}. Error: ${o}`})}),r.on("error",i=>{t({success:!1,error:`Failed to start process: ${i.message}`})})})}async fileExists(e){try{return await p.promises.access(e),!0}catch{return!1}}async listGeneratedMidi(){try{return(await p.promises.readdir(this.outputDir)).filter(t=>t.endsWith(".mid"))}catch{return[]}}async getMidiMetadata(e){try{let t=e.replace(".mid","_metadata.json"),r=await p.promises.readFile(t,"utf-8");return JSON.parse(r)}catch{return null}}async listMidiTemplates(){try{return(await p.promises.readdir(this.templatesDir)).filter(t=>t.endsWith(".mid")||t.endsWith(".midi"))}catch{return[]}}async generateFromTemplate(e,t){try{let r=v.default.join(this.templatesDir,e);if(!await this.fileExists(r))return{success:!1,error:`Template ${e} not found`};let a=Date.now(),i=e.replace(/\.(mid|midi)$/,""),d=v.default.join(this.outputDir,`${i}_custom_${a}.mid`);await p.promises.copyFile(r,d);let n={source_template:e,generated_at:new Date().toISOString(),customizations:t||{},generation_method:"template_based"},u=d.replace(".mid","_metadata.json");return await p.promises.writeFile(u,JSON.stringify(n,null,2)),{success:!0,midiPath:d,metadataPath:u}}catch(r){return{success:!1,error:`Template generation failed: ${r}`}}}async catalogTemplates(){try{let e=await this.executePythonScript(["./server/midi-catalog.py","--scan"]);return e.success?{success:!0,catalogPath:"./storage/midi/templates/midi_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Catalog generation failed: ${e}`}}}async extractGrooveDataset(){try{let e=await this.executePythonScript(["./server/groove-dataset-loader.py","--extract"]);return e.success?{success:!0,catalogPath:"./storage/midi/groove/metadata/groove_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Groove dataset extraction failed: ${e}`}}}async getGroovesByStyle(e){try{return(await this.executePythonScript(["./server/groove-dataset-loader.py","--style",e])).success?[]:[]}catch{return[]}}async getGroovesByTempo(e,t){try{return(await this.executePythonScript(["./server/groove-dataset-loader.py","--tempo-min",e.toString(),"--tempo-max",t.toString()])).success?[]:[]}catch{return[]}}async processChordSets(){try{let e=await this.executePythonScript(["./server/chord-sets-processor.py","--process"]);return e.success?{success:!0,catalogPath:"./storage/midi/templates/chord-sets/chord_sets_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Chord sets processing failed: ${e}`}}}async getChordSetsByCategory(e,t){try{let r=["./server/chord-sets-processor.py","--list"];return e&&r.push("--category",e),t&&(r.push("--tempo-min",t[0].toString()),r.push("--tempo-max",t[1].toString())),(await this.executePythonScript(r)).success?[]:[]}catch{return[]}}async generateFromChordSet(e,t){try{let r=v.default.join("./storage/midi/templates/chord-sets",e);if(!await this.fileExists(r))return{success:!1,error:`Chord set ${e} not found`};let a=Date.now(),i=e.replace(/\.(mid|midi)$/,""),d=v.default.join(this.outputDir,`${i}_generated_${a}.mid`);await p.promises.copyFile(r,d);let n={source_chord_set:e,generated_at:new Date().toISOString(),customizations:t||{},generation_method:"chord_set_based"},u=d.replace(".mid","_metadata.json");return await p.promises.writeFile(u,JSON.stringify(n,null,2)),{success:!0,midiPath:d,metadataPath:u}}catch(r){return{success:!1,error:`Chord set generation failed: ${r}`}}}};var B=require("express"),M=l(require("path"),1),k=l(require("fs/promises"),1),L=l(require("multer"),1),I=(0,B.Router)(),ne=(0,L.default)({dest:M.default.join(process.cwd(),"storage","temp"),limits:{fileSize:50*1024*1024}});I.post("/clone",ne.single("audio"),async(s,e)=>{try{let{text:t,voiceId:r}=s.body;if(!s.file||!t)return e.status(400).json({error:"Audio file and text are required for voice cloning"});let a={success:!0,voiceId:`rvc_${Date.now()}`,audioUrl:`/storage/voices/cloned_${Date.now()}.wav`,message:"Voice cloned successfully (mock mode)"};e.json(a)}catch(t){console.error("Voice cloning error:",t),e.status(500).json({error:"Voice cloning failed",details:t.message})}});I.post("/synthesize",async(s,e)=>{try{let{text:t,voiceId:r,midiPath:o}=s.body;if(!t||!r)return e.status(400).json({error:"Text and voice ID are required for synthesis"});let a={success:!0,audioUrl:`/storage/voices/synthesized_${Date.now()}.wav`,midiIntegration:!!o,message:"Voice synthesized successfully"};e.json(a)}catch(t){console.error("Voice synthesis error:",t),e.status(500).json({error:"Voice synthesis failed",details:t.message})}});I.get("/available",async(s,e)=>{try{let t=M.default.join(process.cwd(),"storage","voice-bank","samples"),o=(await k.default.readdir(t)).filter(a=>a.endsWith(".mp3")||a.endsWith(".wav")).map(a=>({id:a.replace(/\.(mp3|wav)$/,""),name:a.replace(/\.(mp3|wav)$/,"").replace(/_/g," "),file:a}));e.json({voices:o})}catch(t){console.error("Error fetching voices:",t),e.status(500).json({error:"Failed to fetch available voices",details:t.message})}});var V=I;var W=require("express");var z=l(require("path"),1),y=(0,W.Router)(),P=new j;y.post("/generate",async(s,e)=>{try{let{title:t,theme:r,genre:o,tempo:a,duration:i,useAiLyrics:d}=s.body;if(!t||!r||!o||!a)return e.status(400).json({error:"Missing required fields: title, theme, genre, tempo"});let n=await P.generateMidi({title:t,theme:r,genre:o,tempo:parseInt(a),duration:i?parseInt(i):void 0,useAiLyrics:!!d});n.success?e.json({success:!0,midiPath:n.midiPath,metadataPath:n.metadataPath,message:"MIDI generated successfully"}):e.status(500).json({success:!1,error:n.error})}catch(t){console.error("MIDI generation error:",t),e.status(500).json({error:`MIDI generation failed: ${t}`})}});y.get("/list",async(s,e)=>{try{let t=await P.listGeneratedMidi();e.json({files:t})}catch(t){console.error("Error listing MIDI files:",t),e.status(500).json({error:`Failed to list MIDI files: ${t}`})}});y.get("/:filename/metadata",async(s,e)=>{try{let t=s.params.filename,r=z.default.join("./storage/midi/generated",t),o=await P.getMidiMetadata(r);o?e.json(o):e.status(404).json({error:"Metadata not found"})}catch(t){console.error("Error getting metadata:",t),e.status(500).json({error:`Failed to get metadata: ${t}`})}});y.post("/groove/extract",async(s,e)=>{try{let t=await P.extractGrooveDataset();t.success?e.json({success:!0,message:"Groove dataset extracted successfully",catalogPath:t.catalogPath}):e.status(500).json({success:!1,error:t.error})}catch(t){console.error("Groove extraction error:",t),e.status(500).json({error:`Groove extraction failed: ${t}`})}});y.get("/groove/style/:style",async(s,e)=>{try{let t=s.params.style,r=await P.getGroovesByStyle(t);e.json({style:t,grooves:r})}catch(t){console.error("Error getting grooves by style:",t),e.status(500).json({error:`Failed to get grooves: ${t}`})}});y.get("/groove/tempo/:minTempo/:maxTempo",async(s,e)=>{try{let t=parseInt(s.params.minTempo),r=parseInt(s.params.maxTempo);if(isNaN(t)||isNaN(r))return e.status(400).json({error:"Invalid tempo values"});let o=await P.getGroovesByTempo(t,r);e.json({tempoRange:{min:t,max:r},grooves:o})}catch(t){console.error("Error getting grooves by tempo:",t),e.status(500).json({error:`Failed to get grooves: ${t}`})}});var O=y;var N=require("express");var E=require("child_process"),f=l(require("path"),1),x=l(require("fs/promises"),1),D=class{pythonPath;scriptPath;constructor(){this.pythonPath="python3",this.scriptPath=f.default.join(process.cwd(),"temp-dreamsound-repo"),this.ensureDirectories()}async ensureDirectories(){let e=["storage/models/audioldm2","storage/music/generated","storage/temp"];for(let t of e)await x.default.mkdir(f.default.join(process.cwd(),t),{recursive:!0}).catch(()=>{})}async generatePersonalizedMusic(e,t){let r=f.default.join(t.outputDir,`generated_${Date.now()}.wav`),o=[f.default.join(this.scriptPath,"inference_audioldm2.py"),"--prompt",e,"--model_path",t.modelPath,"--output_file",r,"--num_inference_steps",(t.numInferenceSteps||50).toString(),"--guidance_scale",(t.guidanceScale||3.5).toString(),"--audio_length_in_s",(t.audioLengthInS||10).toString()];return t.instanceWord&&t.objectClass&&(o.push("--instance_word",t.instanceWord),o.push("--object_class",t.objectClass)),new Promise((a,i)=>{let d=(0,E.spawn)(this.pythonPath,o),n="",u="";d.stdout.on("data",h=>{n+=h.toString()}),d.stderr.on("data",h=>{u+=h.toString()}),d.on("close",h=>{h===0?a(r):i(new Error(`AudioLDM2 generation failed: ${u}`))}),d.on("error",h=>{i(new Error(`Failed to start AudioLDM2 process: ${h.message}`))})})}async trainDreamBooth(e){let t=[f.default.join(this.scriptPath,"dreambooth_audioldm2.py"),"--pretrained_model_name_or_path","cvssp/audioldm2","--train_data_dir",e.dataDir,"--instance_word",e.instanceWord,"--object_class",e.objectClass,"--output_dir",e.outputDir,"--train_batch_size","1","--gradient_accumulation_steps","4","--max_train_steps",(e.maxTrainSteps||300).toString(),"--learning_rate",(e.learningRate||1e-5).toString(),"--validation_steps","50","--num_validation_audio_files","3","--save_as_full_pipeline"];return new Promise((r,o)=>{let a=(0,E.spawn)("accelerate",["launch",...t]),i="",d="";a.stdout.on("data",n=>{i+=n.toString(),console.log("Training output:",n.toString())}),a.stderr.on("data",n=>{d+=n.toString(),console.error("Training error:",n.toString())}),a.on("close",n=>{n===0?r(f.default.join(e.outputDir,"trained_pipeline")):o(new Error(`DreamBooth training failed: ${d}`))}),a.on("error",n=>{o(new Error(`Failed to start training process: ${n.message}`))})})}async getAvailableModels(){let e=f.default.join(process.cwd(),"storage","models","audioldm2");try{return await x.default.access(e),(await x.default.readdir(e)).filter(r=>r.endsWith(".pt")||r.endsWith(".ckpt"))}catch{return["cvssp/audioldm2"]}}};var g=l(require("path"),1),w=l(require("fs/promises"),1),q=l(require("multer"),1),_=(0,N.Router)(),T=new D,ce=(0,q.default)({dest:g.default.join(process.cwd(),"storage","temp"),limits:{fileSize:100*1024*1024}});_.post("/generate",async(s,e)=>{try{let{prompt:t,instanceWord:r,objectClass:o,audioLength:a=10}=s.body;if(!t)return e.status(400).json({error:"Prompt is required"});let i=g.default.join(process.cwd(),"storage","music","generated");await w.default.mkdir(i,{recursive:!0});let d={modelPath:"cvssp/audioldm2",outputDir:i,instanceWord:r,objectClass:o,audioLengthInS:a},n=await T.generatePersonalizedMusic(t,d);e.json({success:!0,audioFile:g.default.basename(n),message:"Music generated successfully"})}catch(t){console.error("AudioLDM2 generation error:",t),e.status(500).json({error:"Failed to generate music",details:t.message})}});_.post("/train",ce.array("audio_files"),async(s,e)=>{try{let{instanceWord:t,objectClass:r,maxTrainSteps:o=300}=s.body;if(!t||!r)return e.status(400).json({error:"Instance word and object class are required"});if(!s.files||s.files.length===0)return e.status(400).json({error:"Audio files are required for training"});let a=g.default.join(process.cwd(),"storage","models","training",`${t}_${r}_${Date.now()}`);await w.default.mkdir(a,{recursive:!0});let i=s.files;for(let u of i){let h=g.default.join(a,u.originalname);await w.default.rename(u.path,h)}let d=g.default.join(process.cwd(),"storage","models","audioldm2",`${t}_${r}`),n={dataDir:a,instanceWord:t,objectClass:r,outputDir:d,maxTrainSteps:parseInt(o)};T.trainDreamBooth(n).then(u=>{console.log("Training completed:",u)}).catch(u=>{console.error("Training failed:",u)}),e.json({success:!0,message:"Training started successfully",trainingId:g.default.basename(d)})}catch(t){console.error("Training error:",t),e.status(500).json({error:"Failed to start training",details:t.message})}});_.get("/models",async(s,e)=>{try{let t=await T.getAvailableModels();e.json({models:t})}catch(t){console.error("Error fetching models:",t),e.status(500).json({error:"Failed to fetch models",details:t.message})}});_.get("/training/:trainingId/status",async(s,e)=>{try{let{trainingId:t}=s.params,r=g.default.join(process.cwd(),"storage","models","audioldm2",t);try{await w.default.access(g.default.join(r,"trained_pipeline")),e.json({status:"completed"})}catch{try{await w.default.access(r),e.json({status:"training"})}catch{e.json({status:"not_found"})}}}catch(t){console.error("Error checking training status:",t),e.status(500).json({error:"Failed to check training status",details:t.message})}});var U=_;var F={};J.default.config();var Q=typeof F<"u"?(0,H.fileURLToPath)(F.url):Q,$=typeof F<"u"?b.default.dirname(Q):$,X=new Y.default(process.env.STRIPE_SECRET_KEY||"",{apiVersion:"2024-06-20"}),c=(0,m.default)(),K=process.env.PORT||5e3,R=new j;c.use((0,A.default)());c.use(m.default.json({limit:"50mb"}));c.use(m.default.urlencoded({extended:!0,limit:"50mb"}));c.use(m.default.static(b.default.join($,"../dist/public")));c.get("/api/health",async(s,e)=>{try{e.json({status:"healthy",timestamp:new Date().toISOString(),services:{server:!0,database:!0,stripe:!!process.env.STRIPE_SECRET_KEY,audioldm2:!0}})}catch(t){e.status(500).json({status:"unhealthy",error:t.message,timestamp:new Date().toISOString()})}});c.get("/api/status",(s,e)=>{e.json({message:"Burnt Beats API is running",version:"1.0.0",environment:process.env.NODE_ENV||"development"})});c.get("/api/stripe/config",(s,e)=>{e.json({publishableKey:process.env.STRIPE_PUBLISHABLE_KEY,success:!0})});c.post("/api/stripe/create-payment-intent",async(s,e)=>{try{let{amount:t,currency:r="usd",userId:o,planType:a}=s.body;if(!t||!o)return e.status(400).json({error:"Amount and userId are required"});let i=await X.paymentIntents.create({amount:Math.round(t),currency:r,metadata:{userId:o,planType:a||"standard"},automatic_payment_methods:{enabled:!0}});e.json({clientSecret:i.client_secret,success:!0})}catch(t){console.error("Payment intent creation failed:",t),e.status(500).json({error:"Payment processing failed",message:t.message})}});c.post("/webhook/stripe",m.default.raw({type:"application/json"}),(s,e)=>{let t=s.headers["stripe-signature"],r=process.env.STRIPE_WEBHOOK_SECRET,o;try{o=X.webhooks.constructEvent(s.body,t,r)}catch(a){return console.error("Webhook signature verification failed:",a.message),e.status(400).send(`Webhook Error: ${a.message}`)}switch(o.type){case"payment_intent.succeeded":let a=o.data.object;console.log("Payment succeeded:",a.id);break;case"payment_intent.payment_failed":console.log("Payment failed:",o.data.object.id);break;default:console.log(`Unhandled event type: ${o.type}`)}e.json({received:!0})});c.get("/api/stripe/plans",(s,e)=>{e.json({plans:[{id:"basic",name:"Basic Plan",price:299,songs:10,features:["Basic AI generation","Standard quality"]},{id:"pro",name:"Pro Plan",price:499,songs:50,features:["Advanced AI","High quality","Voice cloning"]},{id:"premium",name:"Premium Plan",price:999,songs:"unlimited",features:["All features","Priority support","Commercial license"]}]})});c.get("*",(s,e)=>{e.sendFile(b.default.join($,"../dist/public","index.html"))});c.use((s,e,t,r)=>{console.error("Server error:",s),t.status(500).json({error:"Internal server error",message:process.env.NODE_ENV==="development"?s.message:"Something went wrong"})});c.post("/api/generate-midi",async(s,e)=>{try{let{title:t,theme:r,genre:o,tempo:a,duration:i,useAiLyrics:d}=s.body;if(!t||!r||!o||!a)return e.status(400).json({error:"Missing required fields: title, theme, genre, tempo"});let n=await R.generateMidi({title:t,theme:r,genre:o,tempo:parseInt(a),duration:i?parseInt(i):void 0,useAiLyrics:!!d});n.success?e.json({success:!0,midiPath:n.midiPath,metadataPath:n.metadataPath,message:"MIDI generated successfully"}):e.status(500).json({success:!1,error:n.error})}catch(t){e.status(500).json({error:`MIDI generation failed: ${t}`})}});c.get("/api/midi/list",async(s,e)=>{try{let t=await R.listGeneratedMidi();e.json({files:t})}catch(t){e.status(500).json({error:`Failed to list MIDI files: ${t}`})}});c.get("/api/midi/:filename/metadata",async(s,e)=>{try{let t=s.params.filename,r=(0,Z.join)("./storage/midi/generated",t),o=await R.getMidiMetadata(r);o?e.json(o):e.status(404).json({error:"Metadata not found"})}catch(t){e.status(500).json({error:`Failed to get metadata: ${t}`})}});c.post("/api/voice/clone",async(s,e)=>{try{let{audioPath:t,text:r,voiceId:o}=s.body;if(!t||!r)return e.status(400).json({error:"Audio path and text are required for voice cloning"});let a={success:!0,voiceId:`rvc_${Date.now()}`,audioUrl:`/storage/voices/cloned_${Date.now()}.wav`,message:"Voice cloned successfully (mock mode)"};e.json(a)}catch(t){e.status(500).json({error:`Voice cloning failed: ${t}`})}});c.post("/api/voice/synthesize",async(s,e)=>{try{let{text:t,voiceId:r,midiPath:o}=s.body;if(!t||!r)return e.status(400).json({error:"Text and voice ID are required for synthesis"});let a={success:!0,audioUrl:`/storage/voices/synthesized_${Date.now()}.wav`,midiIntegration:!!o,message:"Voice synthesized successfully"};e.json(a)}catch(t){e.status(500).json({error:`Voice synthesis failed: ${t}`})}});c.use(m.default.json({limit:"50mb"}));c.use(m.default.urlencoded({extended:!0,limit:"50mb"}));c.use((0,A.default)({origin:process.env.NODE_ENV==="production"?["https://burntbeats.replit.app","https://burnt-beats.replit.app"]:["http://localhost:3000","http://localhost:5000"],credentials:!0}));c.use("/storage",m.default.static(b.default.join($,"../storage")));c.use("/midi",m.default.static("./storage/midi/generated"));c.use("/storage/voices",m.default.static("./storage/voices"));c.use("/storage/music",m.default.static("./storage/music"));c.use("/storage/temp",m.default.static("./storage/temp"));c.use("/api/voice",V);c.use("/api/midi",O);c.use("/api/audioldm2",U);c.listen(K,"0.0.0.0",()=>{console.log(`\u{1F525} Burnt Beats server running on http://0.0.0.0:${K}`),console.log("\u{1F3B5} MIDI generation available"),console.log("\u{1F5E3}\uFE0F  Voice cloning available (mock mode)"),console.log(`Environment: ${process.env.NODE_ENV||"development"}`)});var de=c;
