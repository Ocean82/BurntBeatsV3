import l from"express";import R from"cors";import S from"path";import{fileURLToPath as C}from"url";import H from"dotenv";import J from"stripe";import{join as Y}from"path";import{spawn as k}from"child_process";import{promises as p}from"fs";import j from"path";var y=class{pythonPath="python3";generatorScript="./music Gen extra/Main.py";outputDir="./storage/midi/generated";templatesDir="./storage/midi/templates";async generateMidi(e){try{await p.mkdir(this.outputDir,{recursive:!0});let t=Date.now(),r=e.title.replace(/[^a-zA-Z0-9]/g,"_"),o=j.join(this.outputDir,`${r}_${t}.mid`),a=["./server/enhanced-midi-generator.py","--title",e.title,"--theme",e.theme,"--genre",e.genre,"--tempo",e.tempo.toString(),"--output",o];e.useAiLyrics&&a.push("--ai-lyrics"),e.duration&&a.push("--duration",e.duration.toString()),e.voiceId&&a.push("--voice-id",e.voiceId);let i=await this.executePythonScript(a);if(i.success){let d=await this.fileExists(o),n=o.replace(".mid","_metadata.json"),u=await this.fileExists(n);return{success:d,midiPath:d?o:void 0,metadataPath:u?n:void 0,error:d?void 0:"MIDI file was not generated"}}else return{success:!1,error:i.error}}catch(t){return{success:!1,error:`MIDI generation failed: ${t}`}}}async executePythonScript(e){return new Promise(t=>{let r=k(this.pythonPath,e),o="",a="";r.stdout.on("data",i=>{a+=i.toString()}),r.stderr.on("data",i=>{o+=i.toString()}),r.on("close",i=>{t(i===0?{success:!0}:{success:!1,error:`Process exited with code ${i}. Error: ${o}`})}),r.on("error",i=>{t({success:!1,error:`Failed to start process: ${i.message}`})})})}async fileExists(e){try{return await p.access(e),!0}catch{return!1}}async listGeneratedMidi(){try{return(await p.readdir(this.outputDir)).filter(t=>t.endsWith(".mid"))}catch{return[]}}async getMidiMetadata(e){try{let t=e.replace(".mid","_metadata.json"),r=await p.readFile(t,"utf-8");return JSON.parse(r)}catch{return null}}async listMidiTemplates(){try{return(await p.readdir(this.templatesDir)).filter(t=>t.endsWith(".mid")||t.endsWith(".midi"))}catch{return[]}}async generateFromTemplate(e,t){try{let r=j.join(this.templatesDir,e);if(!await this.fileExists(r))return{success:!1,error:`Template ${e} not found`};let a=Date.now(),i=e.replace(/\.(mid|midi)$/,""),d=j.join(this.outputDir,`${i}_custom_${a}.mid`);await p.copyFile(r,d);let n={source_template:e,generated_at:new Date().toISOString(),customizations:t||{},generation_method:"template_based"},u=d.replace(".mid","_metadata.json");return await p.writeFile(u,JSON.stringify(n,null,2)),{success:!0,midiPath:d,metadataPath:u}}catch(r){return{success:!1,error:`Template generation failed: ${r}`}}}async catalogTemplates(){try{let e=await this.executePythonScript(["./server/midi-catalog.py","--scan"]);return e.success?{success:!0,catalogPath:"./storage/midi/templates/midi_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Catalog generation failed: ${e}`}}}async extractGrooveDataset(){try{let e=await this.executePythonScript(["./server/groove-dataset-loader.py","--extract"]);return e.success?{success:!0,catalogPath:"./storage/midi/groove/metadata/groove_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Groove dataset extraction failed: ${e}`}}}async getGroovesByStyle(e){try{return(await this.executePythonScript(["./server/groove-dataset-loader.py","--style",e])).success?[]:[]}catch{return[]}}async getGroovesByTempo(e,t){try{return(await this.executePythonScript(["./server/groove-dataset-loader.py","--tempo-min",e.toString(),"--tempo-max",t.toString()])).success?[]:[]}catch{return[]}}async processChordSets(){try{let e=await this.executePythonScript(["./server/chord-sets-processor.py","--process"]);return e.success?{success:!0,catalogPath:"./storage/midi/templates/chord-sets/chord_sets_catalog.json"}:{success:!1,error:e.error}}catch(e){return{success:!1,error:`Chord sets processing failed: ${e}`}}}async getChordSetsByCategory(e,t){try{let r=["./server/chord-sets-processor.py","--list"];return e&&r.push("--category",e),t&&(r.push("--tempo-min",t[0].toString()),r.push("--tempo-max",t[1].toString())),(await this.executePythonScript(r)).success?[]:[]}catch{return[]}}async generateFromChordSet(e,t){try{let r=j.join("./storage/midi/templates/chord-sets",e);if(!await this.fileExists(r))return{success:!1,error:`Chord set ${e} not found`};let a=Date.now(),i=e.replace(/\.(mid|midi)$/,""),d=j.join(this.outputDir,`${i}_generated_${a}.mid`);await p.copyFile(r,d);let n={source_chord_set:e,generated_at:new Date().toISOString(),customizations:t||{},generation_method:"chord_set_based"},u=d.replace(".mid","_metadata.json");return await p.writeFile(u,JSON.stringify(n,null,2)),{success:!0,midiPath:d,metadataPath:u}}catch(r){return{success:!1,error:`Chord set generation failed: ${r}`}}}};import{Router as L}from"express";import $ from"path";import V from"fs/promises";import W from"multer";var w=L(),z=W({dest:$.join(process.cwd(),"storage","temp"),limits:{fileSize:50*1024*1024}});w.post("/clone",z.single("audio"),async(s,e)=>{try{let{text:t,voiceId:r}=s.body;if(!s.file||!t)return e.status(400).json({error:"Audio file and text are required for voice cloning"});let a={success:!0,voiceId:`rvc_${Date.now()}`,audioUrl:`/storage/voices/cloned_${Date.now()}.wav`,message:"Voice cloned successfully (mock mode)"};e.json(a)}catch(t){console.error("Voice cloning error:",t),e.status(500).json({error:"Voice cloning failed",details:t.message})}});w.post("/synthesize",async(s,e)=>{try{let{text:t,voiceId:r,midiPath:o}=s.body;if(!t||!r)return e.status(400).json({error:"Text and voice ID are required for synthesis"});let a={success:!0,audioUrl:`/storage/voices/synthesized_${Date.now()}.wav`,midiIntegration:!!o,message:"Voice synthesized successfully"};e.json(a)}catch(t){console.error("Voice synthesis error:",t),e.status(500).json({error:"Voice synthesis failed",details:t.message})}});w.get("/available",async(s,e)=>{try{let t=$.join(process.cwd(),"storage","voice-bank","samples"),o=(await V.readdir(t)).filter(a=>a.endsWith(".mp3")||a.endsWith(".wav")).map(a=>({id:a.replace(/\.(mp3|wav)$/,""),name:a.replace(/\.(mp3|wav)$/,"").replace(/_/g," "),file:a}));e.json({voices:o})}catch(t){console.error("Error fetching voices:",t),e.status(500).json({error:"Failed to fetch available voices",details:t.message})}});var M=w;import{Router as O}from"express";import N from"path";var h=O(),v=new y;h.post("/generate",async(s,e)=>{try{let{title:t,theme:r,genre:o,tempo:a,duration:i,useAiLyrics:d}=s.body;if(!t||!r||!o||!a)return e.status(400).json({error:"Missing required fields: title, theme, genre, tempo"});let n=await v.generateMidi({title:t,theme:r,genre:o,tempo:parseInt(a),duration:i?parseInt(i):void 0,useAiLyrics:!!d});n.success?e.json({success:!0,midiPath:n.midiPath,metadataPath:n.metadataPath,message:"MIDI generated successfully"}):e.status(500).json({success:!1,error:n.error})}catch(t){console.error("MIDI generation error:",t),e.status(500).json({error:`MIDI generation failed: ${t}`})}});h.get("/list",async(s,e)=>{try{let t=await v.listGeneratedMidi();e.json({files:t})}catch(t){console.error("Error listing MIDI files:",t),e.status(500).json({error:`Failed to list MIDI files: ${t}`})}});h.get("/:filename/metadata",async(s,e)=>{try{let t=s.params.filename,r=N.join("./storage/midi/generated",t),o=await v.getMidiMetadata(r);o?e.json(o):e.status(404).json({error:"Metadata not found"})}catch(t){console.error("Error getting metadata:",t),e.status(500).json({error:`Failed to get metadata: ${t}`})}});h.post("/groove/extract",async(s,e)=>{try{let t=await v.extractGrooveDataset();t.success?e.json({success:!0,message:"Groove dataset extracted successfully",catalogPath:t.catalogPath}):e.status(500).json({success:!1,error:t.error})}catch(t){console.error("Groove extraction error:",t),e.status(500).json({error:`Groove extraction failed: ${t}`})}});h.get("/groove/style/:style",async(s,e)=>{try{let t=s.params.style,r=await v.getGroovesByStyle(t);e.json({style:t,grooves:r})}catch(t){console.error("Error getting grooves by style:",t),e.status(500).json({error:`Failed to get grooves: ${t}`})}});h.get("/groove/tempo/:minTempo/:maxTempo",async(s,e)=>{try{let t=parseInt(s.params.minTempo),r=parseInt(s.params.maxTempo);if(isNaN(t)||isNaN(r))return e.status(400).json({error:"Invalid tempo values"});let o=await v.getGroovesByTempo(t,r);e.json({tempoRange:{min:t,max:r},grooves:o})}catch(t){console.error("Error getting grooves by tempo:",t),e.status(500).json({error:`Failed to get grooves: ${t}`})}});var E=h;import{Router as q}from"express";import{spawn as T}from"child_process";import f from"path";import I from"fs/promises";var b=class{pythonPath;scriptPath;constructor(){this.pythonPath="python3",this.scriptPath=f.join(process.cwd(),"temp-dreamsound-repo"),this.ensureDirectories()}async ensureDirectories(){let e=["storage/models/audioldm2","storage/music/generated","storage/temp"];for(let t of e)await I.mkdir(f.join(process.cwd(),t),{recursive:!0}).catch(()=>{})}async generatePersonalizedMusic(e,t){let r=f.join(t.outputDir,`generated_${Date.now()}.wav`),o=[f.join(this.scriptPath,"inference_audioldm2.py"),"--prompt",e,"--model_path",t.modelPath,"--output_file",r,"--num_inference_steps",(t.numInferenceSteps||50).toString(),"--guidance_scale",(t.guidanceScale||3.5).toString(),"--audio_length_in_s",(t.audioLengthInS||10).toString()];return t.instanceWord&&t.objectClass&&(o.push("--instance_word",t.instanceWord),o.push("--object_class",t.objectClass)),new Promise((a,i)=>{let d=T(this.pythonPath,o),n="",u="";d.stdout.on("data",m=>{n+=m.toString()}),d.stderr.on("data",m=>{u+=m.toString()}),d.on("close",m=>{m===0?a(r):i(new Error(`AudioLDM2 generation failed: ${u}`))}),d.on("error",m=>{i(new Error(`Failed to start AudioLDM2 process: ${m.message}`))})})}async trainDreamBooth(e){let t=[f.join(this.scriptPath,"dreambooth_audioldm2.py"),"--pretrained_model_name_or_path","cvssp/audioldm2","--train_data_dir",e.dataDir,"--instance_word",e.instanceWord,"--object_class",e.objectClass,"--output_dir",e.outputDir,"--train_batch_size","1","--gradient_accumulation_steps","4","--max_train_steps",(e.maxTrainSteps||300).toString(),"--learning_rate",(e.learningRate||1e-5).toString(),"--validation_steps","50","--num_validation_audio_files","3","--save_as_full_pipeline"];return new Promise((r,o)=>{let a=T("accelerate",["launch",...t]),i="",d="";a.stdout.on("data",n=>{i+=n.toString(),console.log("Training output:",n.toString())}),a.stderr.on("data",n=>{d+=n.toString(),console.error("Training error:",n.toString())}),a.on("close",n=>{n===0?r(f.join(e.outputDir,"trained_pipeline")):o(new Error(`DreamBooth training failed: ${d}`))}),a.on("error",n=>{o(new Error(`Failed to start training process: ${n.message}`))})})}async getAvailableModels(){let e=f.join(process.cwd(),"storage","models","audioldm2");try{return await I.access(e),(await I.readdir(e)).filter(r=>r.endsWith(".pt")||r.endsWith(".ckpt"))}catch{return["cvssp/audioldm2"]}}};import g from"path";import P from"fs/promises";import U from"multer";var _=q(),D=new b,K=U({dest:g.join(process.cwd(),"storage","temp"),limits:{fileSize:100*1024*1024}});_.post("/generate",async(s,e)=>{try{let{prompt:t,instanceWord:r,objectClass:o,audioLength:a=10}=s.body;if(!t)return e.status(400).json({error:"Prompt is required"});let i=g.join(process.cwd(),"storage","music","generated");await P.mkdir(i,{recursive:!0});let d={modelPath:"cvssp/audioldm2",outputDir:i,instanceWord:r,objectClass:o,audioLengthInS:a},n=await D.generatePersonalizedMusic(t,d);e.json({success:!0,audioFile:g.basename(n),message:"Music generated successfully"})}catch(t){console.error("AudioLDM2 generation error:",t),e.status(500).json({error:"Failed to generate music",details:t.message})}});_.post("/train",K.array("audio_files"),async(s,e)=>{try{let{instanceWord:t,objectClass:r,maxTrainSteps:o=300}=s.body;if(!t||!r)return e.status(400).json({error:"Instance word and object class are required"});if(!s.files||s.files.length===0)return e.status(400).json({error:"Audio files are required for training"});let a=g.join(process.cwd(),"storage","models","training",`${t}_${r}_${Date.now()}`);await P.mkdir(a,{recursive:!0});let i=s.files;for(let u of i){let m=g.join(a,u.originalname);await P.rename(u.path,m)}let d=g.join(process.cwd(),"storage","models","audioldm2",`${t}_${r}`),n={dataDir:a,instanceWord:t,objectClass:r,outputDir:d,maxTrainSteps:parseInt(o)};D.trainDreamBooth(n).then(u=>{console.log("Training completed:",u)}).catch(u=>{console.error("Training failed:",u)}),e.json({success:!0,message:"Training started successfully",trainingId:g.basename(d)})}catch(t){console.error("Training error:",t),e.status(500).json({error:"Failed to start training",details:t.message})}});_.get("/models",async(s,e)=>{try{let t=await D.getAvailableModels();e.json({models:t})}catch(t){console.error("Error fetching models:",t),e.status(500).json({error:"Failed to fetch models",details:t.message})}});_.get("/training/:trainingId/status",async(s,e)=>{try{let{trainingId:t}=s.params,r=g.join(process.cwd(),"storage","models","audioldm2",t);try{await P.access(g.join(r,"trained_pipeline")),e.json({status:"completed"})}catch{try{await P.access(r),e.json({status:"training"})}catch{e.json({status:"not_found"})}}}catch(t){console.error("Error checking training status:",t),e.status(500).json({error:"Failed to check training status",details:t.message})}});var F=_;H.config();var Z=()=>{try{if(typeof import.meta<"u"&&import.meta.url)return C(import.meta.url)}catch{}return __filename},Q=()=>{try{if(typeof import.meta<"u"&&import.meta.url)return S.dirname(C(import.meta.url))}catch{}return __dirname},Te=Z(),G=Q(),B=new J(process.env.STRIPE_SECRET_KEY||"",{apiVersion:"2024-06-20"}),c=l(),A=process.env.PORT||5e3,x=new y;c.use(R());c.use(l.json({limit:"50mb"}));c.use(l.urlencoded({extended:!0,limit:"50mb"}));c.use(l.static(S.join(G,"../dist/public")));c.get("/api/health",async(s,e)=>{try{e.json({status:"healthy",timestamp:new Date().toISOString(),services:{server:!0,database:!0,stripe:!!process.env.STRIPE_SECRET_KEY,audioldm2:!0}})}catch(t){e.status(500).json({status:"unhealthy",error:t.message,timestamp:new Date().toISOString()})}});c.get("/api/status",(s,e)=>{e.json({message:"Burnt Beats API is running",version:"1.0.0",environment:process.env.NODE_ENV||"development"})});c.get("/api/stripe/config",(s,e)=>{e.json({publishableKey:process.env.STRIPE_PUBLISHABLE_KEY,success:!0})});c.post("/api/stripe/create-payment-intent",async(s,e)=>{try{let{amount:t,currency:r="usd",userId:o,planType:a}=s.body;if(!t||!o)return e.status(400).json({error:"Amount and userId are required"});let i=await B.paymentIntents.create({amount:Math.round(t),currency:r,metadata:{userId:o,planType:a||"standard"},automatic_payment_methods:{enabled:!0}});e.json({clientSecret:i.client_secret,success:!0})}catch(t){console.error("Payment intent creation failed:",t),e.status(500).json({error:"Payment processing failed",message:t.message})}});c.post("/webhook/stripe",l.raw({type:"application/json"}),(s,e)=>{let t=s.headers["stripe-signature"],r=process.env.STRIPE_WEBHOOK_SECRET,o;try{o=B.webhooks.constructEvent(s.body,t,r)}catch(a){return console.error("Webhook signature verification failed:",a.message),e.status(400).send(`Webhook Error: ${a.message}`)}switch(o.type){case"payment_intent.succeeded":let a=o.data.object;console.log("Payment succeeded:",a.id);break;case"payment_intent.payment_failed":console.log("Payment failed:",o.data.object.id);break;default:console.log(`Unhandled event type: ${o.type}`)}e.json({received:!0})});c.get("/api/stripe/plans",(s,e)=>{e.json({plans:[{id:"basic",name:"Basic Plan",price:299,songs:10,features:["Basic AI generation","Standard quality"]},{id:"pro",name:"Pro Plan",price:499,songs:50,features:["Advanced AI","High quality","Voice cloning"]},{id:"premium",name:"Premium Plan",price:999,songs:"unlimited",features:["All features","Priority support","Commercial license"]}]})});c.get("*",(s,e)=>{e.sendFile(S.join(G,"../dist/public","index.html"))});c.use((s,e,t,r)=>{console.error("Server error:",s),t.status(500).json({error:"Internal server error",message:process.env.NODE_ENV==="development"?s.message:"Something went wrong"})});c.post("/api/generate-midi",async(s,e)=>{try{let{title:t,theme:r,genre:o,tempo:a,duration:i,useAiLyrics:d}=s.body;if(!t||!r||!o||!a)return e.status(400).json({error:"Missing required fields: title, theme, genre, tempo"});let n=await x.generateMidi({title:t,theme:r,genre:o,tempo:parseInt(a),duration:i?parseInt(i):void 0,useAiLyrics:!!d});n.success?e.json({success:!0,midiPath:n.midiPath,metadataPath:n.metadataPath,message:"MIDI generated successfully"}):e.status(500).json({success:!1,error:n.error})}catch(t){e.status(500).json({error:`MIDI generation failed: ${t}`})}});c.get("/api/midi/list",async(s,e)=>{try{let t=await x.listGeneratedMidi();e.json({files:t})}catch(t){e.status(500).json({error:`Failed to list MIDI files: ${t}`})}});c.get("/api/midi/:filename/metadata",async(s,e)=>{try{let t=s.params.filename,r=Y("./storage/midi/generated",t),o=await x.getMidiMetadata(r);o?e.json(o):e.status(404).json({error:"Metadata not found"})}catch(t){e.status(500).json({error:`Failed to get metadata: ${t}`})}});c.post("/api/voice/clone",async(s,e)=>{try{let{audioPath:t,text:r,voiceId:o}=s.body;if(!t||!r)return e.status(400).json({error:"Audio path and text are required for voice cloning"});let a={success:!0,voiceId:`rvc_${Date.now()}`,audioUrl:`/storage/voices/cloned_${Date.now()}.wav`,message:"Voice cloned successfully (mock mode)"};e.json(a)}catch(t){e.status(500).json({error:`Voice cloning failed: ${t}`})}});c.post("/api/voice/synthesize",async(s,e)=>{try{let{text:t,voiceId:r,midiPath:o}=s.body;if(!t||!r)return e.status(400).json({error:"Text and voice ID are required for synthesis"});let a={success:!0,audioUrl:`/storage/voices/synthesized_${Date.now()}.wav`,midiIntegration:!!o,message:"Voice synthesized successfully"};e.json(a)}catch(t){e.status(500).json({error:`Voice synthesis failed: ${t}`})}});c.use(l.json({limit:"50mb"}));c.use(l.urlencoded({extended:!0,limit:"50mb"}));c.use(R({origin:process.env.NODE_ENV==="production"?["https://burntbeats.replit.app","https://burnt-beats.replit.app"]:["http://localhost:3000","http://localhost:5000"],credentials:!0}));c.use("/storage",l.static(S.join(__dirname,"../storage")));c.use("/midi",l.static("./storage/midi/generated"));c.use("/storage/voices",l.static("./storage/voices"));c.use("/storage/music",l.static("./storage/music"));c.use("/storage/temp",l.static("./storage/temp"));c.use("/api/voice",M);c.use("/api/midi",E);c.use("/api/audioldm2",F);c.listen(A,"0.0.0.0",()=>{console.log(`\u{1F525} Burnt Beats server running on http://0.0.0.0:${A}`),console.log("\u{1F3B5} MIDI generation available"),console.log("\u{1F5E3}\uFE0F  Voice cloning available (mock mode)"),console.log(`Environment: ${process.env.NODE_ENV||"development"}`)});var Ce=c;export{Ce as default};
